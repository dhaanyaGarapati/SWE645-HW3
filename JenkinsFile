pipeline {
  agent any
  // Trigger via GitHub webhooks (job config may also have Poll SCM)
  triggers {
    githubPush()
  }
  environment {
    // GKE / GCP details for HW3
    PROJECT   = 'swe645hw3-478221'
    LOCATION  = 'us-central1'      // region
    LOC_FLAG  = '--region'         // use --region for regional clusters
    CLUSTER   = 'survey-cluster'

    // Kubernetes app details
    NAMESPACE = 'survey-app'
    DEPLOY    = 'survey-frontend'  // deployment.metadata.name in your YAML

    // Docker Hub image (owner: dgarapati03)
    IMAGE     = 'dgarapati03/survey-frontend'
    TAG       = "${env.BUILD_NUMBER}"
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        sh 'ls -la'
      }
    }
    stage('Build Docker image') {
      steps {
        sh '''
          set -eu
          echo "Building image: ${IMAGE}:${TAG}"
          docker build -t ${IMAGE}:${TAG} .
        '''
      }
    }
    stage('Push to Docker Hub') {
      steps {
        withCredentials([
          usernamePassword(
            credentialsId: 'dockerhub',   // Jenkins credential for Docker Hub
            usernameVariable: 'U',
            passwordVariable: 'TOKEN'
          )
        ]) {
          sh '''
            set -eu
            echo "$TOKEN" | docker login -u "$U" --password-stdin
            docker push ${IMAGE}:${TAG}
            docker logout
          '''
        }
      }
    }
    stage('GCP auth & connect to GKE') {
      steps {
        withCredentials([
          file(credentialsId: 'gcp-key', variable: 'GOOGLE_APPLICATION_CREDENTIALS')
        ]) {
          sh '''
            set -eu
            gcloud --version
            gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
            gcloud config set project ${PROJECT}
            gcloud container clusters get-credentials ${CLUSTER} ${LOC_FLAG} ${LOCATION} --project ${PROJECT}
            kubectl version --client=true
          '''
        }
      }
    }
    stage('Deploy to Kubernetes (3 replicas)') {
      steps {
        sh '''
          set -eu
          # Ensure namespace exists (idempotent)
          kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
          # Ensure service exists (adjust file name if needed)
          if [ -f k8s-service.yaml ]; then
            kubectl -n ${NAMESPACE} apply -f k8s-service.yaml
          fi
          # Create or update deployment
          if kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1; then
            echo "Updating existing deployment ${DEPLOY}"
            kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} ${DEPLOY}=${IMAGE}:${TAG} \
              || kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} web=${IMAGE}:${TAG}
            kubectl -n ${NAMESPACE} scale deploy/${DEPLOY} --replicas=3
          else
            echo "Creating new deployment ${DEPLOY}"
            kubectl -n ${NAMESPACE} apply -f k8s-deployment.yaml
            kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} ${DEPLOY}=${IMAGE}:${TAG} \
              || kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} web=${IMAGE}:${TAG}
            kubectl -n ${NAMESPACE} scale deploy/${DEPLOY} --replicas=3
          fi
          kubectl -n ${NAMESPACE} rollout status deploy/${DEPLOY} --timeout=180s
          echo "----- Service status -----"
          kubectl -n ${NAMESPACE} get svc -o wide
        '''
      }
    }
  }
  post {
    success {
      echo "Deployed ${IMAGE}:${TAG} to namespace ${NAMESPACE}"
    }
    failure {
      echo "Build/Deploy failed — check the failing stage logs above."
    }
  }
}
